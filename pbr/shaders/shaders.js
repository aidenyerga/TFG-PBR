var shaders={cook_torrance_BRDF:{vert:"varying vec3 f_positionEye;\nvarying vec3 f_viewDirection;\nvarying vec3 f_normal;\nvoid main()\n{\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n	f_positionEye = (modelViewMatrix * vec4(position, 1.0)).xyz;\n	f_viewDirection = -f_positionEye;\n	f_normal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\n}\n",frag:"float PI = 3.1415926535897932384626433832795;\nuniform vec3 matcolor;\nuniform float kd;\nuniform float metallic;\nuniform float roughness;\nuniform float ior;\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\nstruct PointLight {\n	vec3 color;\n	vec3 position;\n};\nstruct SpotLight {\n	vec3 color;\n	vec3 position;\n	vec3 direction;\n	float coneCos;\n	float penumbraCos;\n	float decay;\n};\nuniform vec3 ambientLightColor;\n#if NUM_DIR_LIGHTS > 0\nuniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];\n#endif\n#if NUM_POINT_LIGHTS > 0\nuniform PointLight pointLights[NUM_POINT_LIGHTS];\n#endif\n#if NUM_SPOT_LIGHTS > 0\nuniform SpotLight spotLights[NUM_SPOT_LIGHTS];\n#endif\nvarying vec3 f_positionEye;\nvarying vec3 f_viewDirection;\nvarying vec3 f_normal;\nfloat clampdot(vec3 N, vec3 L) {return max(dot(N, L), 0.0);}\nfloat fresnel_schlick(float cosalpha)\n{\n	float RF0 = pow((ior-1.0)/(ior+1.0), 2.0);\n	return (RF0+(1.0-RF0)*pow((1.0-cosalpha), 5.0));\n}\nfloat D(float dotNH)\n{\n	float expo = (pow(dotNH, 2.0)-1.0)/(pow(dotNH, 2.0)*pow(roughness, 2.0));\n	return exp(expo)/(PI*pow(roughness, 2.0)*pow(dotNH, 4.0));\n}\nvec3 fdiff()\n{return matcolor/PI;}\nfloat fspec(vec3 V, vec3 N, vec3 L)\n{\n	float dotVN = clampdot(V, N);\n	float dotLN = clampdot(L, N);\n	vec3 H = normalize(V+L);\n	float dotNH = clampdot(N, H);\n	float dotHV = clampdot(V, H);\n	float g_f = 2.0*dotNH/dotHV;\n	\n	\n	float G = min(1.0, min(g_f*dotVN, g_f*dotLN));\n	float fresnelR = fresnel_schlick(dotHV);\n	return max((D(dotNH)*fresnelR*G), 0.0)/max(4.0*dotLN*dotVN, 0.000001);\n}\nvec3 f(vec3 V, vec3 N, vec3 L)\n{\n	float fspec = fspec(V, N, L);\n	vec3 fdiff = fdiff();\n	return mix(mix(fspec*vec3(1.0, 1.0, 1.0), fdiff, kd), fspec*matcolor, metallic);\n}\nvoid main()\n{\n	vec3 f_color = vec3(0.0, 0.0, 0.0);\n	vec3 N, L, V;\n	V = normalize(f_viewDirection); \n	N = normalize(f_normal); \n	\n	#if NUM_DIR_LIGHTS > 0\n	for(int i=0; i < NUM_DIR_LIGHTS; ++i) {\n		L = normalize(directionalLights[i].direction); \n		f_color += f(V, N, L)*directionalLights[i].color*clampdot(N, L);\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for(int i=0; i < NUM_POINT_LIGHTS; ++i) {\n		L = normalize(pointLights[i].position-f_positionEye);\n		f_color += f(V, N, L)*pointLights[i].color*clampdot(N, L);\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for (int i=0; i < NUM_SPOT_LIGHTS; ++i) {\n		L = normalize(spotLights[i].position-f_positionEye);\n		float cosls = dot(L, normalize(spotLights[i].direction));\n		float cspot = 0.0;\n		if (cosls > 0.000001) cspot = pow(cosls, spotLights[i].decay);\n		if (!(cspot < 0.000001 || cosls <= spotLights[i].coneCos)) \n		{\n			f_color += cspot*f(V, N, L)*spotLights[i].color*clampdot(N, L);\n		}\n	}\n	#endif\n	f_color += ambientLightColor*matcolor;\n	\n	gl_FragColor = vec4(f_color,1);\n}\n"},dummy:{vert:"uniform vec3 color;\nvoid main()\n{\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n",frag:"uniform vec3 color;\nvoid main()\n{\n	gl_FragColor = vec4(1,1,1,1);\n}\n"},principled_BRDF:{vert:"attribute vec4 tangent;\nvarying vec3 f_positionEye;\nvarying vec3 f_viewDirection;\nvarying vec3 f_normal;\nvarying vec3 x;\nvarying vec3 y;\nvoid main()\n{\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n	f_positionEye = (modelViewMatrix * vec4(position, 1.0)).xyz;\n	f_viewDirection = -f_positionEye;\n	f_normal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\n	\n	\n	vec3 t = normalize(normalMatrix*tangent.xyz);\n	\n	\n	x = normalize(t - dot(t, f_normal) * f_normal);\n	\n	\n	y = normalize(cross(f_normal, t));\n}\n",frag:"float PI = 3.1415926535897932384626433832795;\nuniform vec3 baseColor;\nuniform float subsurface;\nuniform float metallic;\nuniform float specular;\nuniform float specularTint;\nuniform float roughness;\nuniform float anisotropic;\nuniform float sheen;\nuniform float sheenTint;\nuniform float clearcoat;\nuniform float clearcoatGloss;\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\nstruct PointLight {\n	vec3 color;\n	vec3 position;\n};\nstruct SpotLight {\n	vec3 color;\n	vec3 position;\n	vec3 direction;\n	float coneCos;\n	float penumbraCos;\n	float decay;\n};\nuniform vec3 ambientLightColor;\n#if NUM_DIR_LIGHTS > 0\nuniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];\n#endif\n#if NUM_POINT_LIGHTS > 0\nuniform PointLight pointLights[NUM_POINT_LIGHTS];\n#endif\n#if NUM_SPOT_LIGHTS > 0\nuniform SpotLight spotLights[NUM_SPOT_LIGHTS];\n#endif\nvarying vec3 f_positionEye;\nvarying vec3 f_viewDirection;\nvarying vec3 f_normal;\nvarying vec3 x;\nvarying vec3 y;\nfloat clampdot(vec3 N, vec3 L) {return max(dot(N, L), 0.0);}\nfloat DGTR1(float alpha, float dotNH)\n{\n	float a2 = alpha*alpha;\n	float cos2th = dotNH*dotNH;\n	float den = (1.0+(a2-1.0)*cos2th);\n	return (a2-1.0)/(PI*log(a2)*den);\n}\nfloat DGTR2(float alpha, float dotNH)\n{\n	float a2 = alpha*alpha;\n	float cos2th = dotNH*dotNH;\n	float den = (1.0+(a2-1.0)*cos2th);\n	return a2/(PI*den*den);\n}\nfloat DGTR2_aniso(float dotHX, float dotHY, float dotNH, float ax, float ay)\n{\n	float deno = dotHX*dotHX/(ax*ax)+dotHY*dotHY/(ay*ay)+dotNH*dotNH;\n	return 1.0/(PI*ax*ay*deno*deno);\n}\nfloat fresnel_schlick(float RF0, float cosalpha)\n{return (RF0+(1.0-RF0)*pow((1.0-cosalpha), 5.0));}\nvec3 fdiff(float dotHV, float dotLN, float dotVN)\n{\n    float FD90 = 0.5 + 2.0*pow(dotHV, 2.0)*roughness;\n	float d = (1.0+(FD90-1.0)*pow(1.0-dotLN, 5.0))*(1.0+(FD90-1.0)*pow(1.0-dotVN, 5.0));\n    return (baseColor/PI)*d;\n}\nvec3 fss(float dotHV, float dotLN, float dotVN)\n{\n	float FSS90 = dotHV*dotHV*roughness;\n	float ss = (1.0+(FSS90-1.0)*pow(1.0-dotLN, 5.0))*(1.0+(FSS90-1.0)*pow(1.0-dotVN, 5.0));\n	return (baseColor/PI)*1.25*(ss*(1.0/(dotLN*dotVN) -0.5)+0.5);\n}\nfloat F(float dotVH)\n{\n	\n    \n    float ior = (specular * 0.8) + 1.0 ;\n	\n    \n    float RF0 = pow((ior-1.0)/(ior+1.0), 2.0);\n    return fresnel_schlick(RF0, dotVH);\n}\nfloat smithG_GGX_aniso(float dotVN, float dotVX, float dotVY, float ax, float ay)\n{\n    return 1.0 / (dotVN + sqrt( pow(dotVX*ax, 2.0) + pow(dotVY*ay, 2.0) + pow(dotVN, 2.0) ));\n}\nfloat GGX_G(float dotVN, float alphag)\n{\n    float a = alphag*alphag;\n    float b = dotVN*dotVN;\n    return 1.0/(dotVN + sqrt(a + b - a*b));\n}\nfloat fspec(vec3 L, vec3 H, vec3 V, float dotNH, float dotHV, float dotLN, float dotVN)\n{\n	float r2 = roughness*roughness;\n	float aspect = sqrt(1.0-anisotropic*0.9);\n    float ax = max(0.001, r2/aspect);\n    float ay = max(0.001, r2*aspect);\n    float alphag = pow((0.5 + roughness/2.0), 2.0);\n    return DGTR2_aniso(dot(H, x), dot(H, y), dotNH, ax, ay)*F(dotHV)*smithG_GGX_aniso(dotVN, dot(V,x), dot(V,y), ax, ay)*smithG_GGX_aniso(dotLN, dot(L,x), dot(L,y), ax, ay);\n}\nfloat fccoat(float dotNH, float dotHV, float dotLN, float dotVN)\n{\n	\n	\n	\n	\n	\n    return DGTR1(mix(0.1, 0.001, clearcoatGloss), dotNH)*fresnel_schlick(0.04, dotHV)*GGX_G(dotLN, 0.25)*GGX_G(dotVN, 0.25);\n}\nvec3 fsheen(float dotHV)\n{ return mix(vec3(1.0,1.0,1.0), baseColor, sheenTint)*pow(1.0-dotHV, 5.0); }\nvec3 f(vec3 V, vec3 N, vec3 L)\n{\n	float dotVN = dot(V, N);\n	float dotLN = dot(L, N);\n	if (dotLN < 0.00000001 || dotVN < 0.00000001) return vec3(0.0, 0.0, 0.0);\n	vec3 H = normalize(V+L);\n	float dotNH = dot(N, H);\n	float dotHV = dot(V, H);\n	vec3 diff = fdiff(dotHV, dotLN, dotVN);\n	vec3 ss = fss(dotHV, dotLN, dotVN);\n	float spec = fspec(L, H, V, dotNH, dotHV, dotLN, dotVN);\n	vec3 dielectric = mix(diff, ss, subsurface)+sheen*fsheen(dotHV)+mix(vec3(1.0, 1.0, 1.0), baseColor, specularTint)*spec;\n	vec3 metal = baseColor*spec;\n	vec3 ccoat = vec3(1.0, 1.0, 1.0)*fccoat(dotNH, dotHV, dotLN, dotVN);\n	\n    return mix(dielectric, metal, metallic)+0.25*clearcoat*ccoat;\n}\nvoid main()\n{\n	vec3 f_color = vec3(0.0, 0.0, 0.0);\n	vec3 N, L, V;\n	V = normalize(f_viewDirection); \n	N = normalize(f_normal); \n	\n	#if NUM_DIR_LIGHTS > 0\n	for(int i=0; i < NUM_DIR_LIGHTS; ++i) {\n		L = normalize(directionalLights[i].direction); \n		f_color += f(V, N, L)*directionalLights[i].color*clampdot(N, L);\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for(int i=0; i < NUM_POINT_LIGHTS; ++i) {\n		L = normalize(pointLights[i].position-f_positionEye);\n		f_color += f(V, N, L)*pointLights[i].color*clampdot(N, L);\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for (int i=0; i < NUM_SPOT_LIGHTS; ++i) {\n		L = normalize(spotLights[i].position-f_positionEye);\n		float cosls = dot(L, normalize(spotLights[i].direction));\n		float cspot = 0.0;\n		if (cosls > 0.000001) cspot = pow(cosls, spotLights[i].decay);\n		if (!(cspot < 0.000001 || cosls <= spotLights[i].coneCos)) \n		{\n			f_color += cspot*f(V, N, L)*spotLights[i].color*clampdot(N, L);\n		}\n	}\n	#endif\n	f_color += ambientLightColor*baseColor;\n	\n	gl_FragColor = vec4(f_color,1);\n}\n"}};